#!/usr/bin/env python
# -*- coding: utf-8 -*-

from ....util.zarrds import ZarrDataset
from logging import getLogger
logger = getLogger(__name__)


class CalData(ZarrDataset):
    """
    Calibration Data:
    This class is storing the antenna-based calibration table
    in a single dataset
    """
    # Data type name
    name = "Calibration Dataset"

    # Group Name of zarr file
    zarr_group = "calibration"

    def set_time_from_table(self, timetable):
        """
        Set the time information from the given time table.

        Args:
            timetable (pd.DataFrame): 
                The time segment information. It can be generated by
                uvd.scan.segment_scan method.
        """
        self.ds.coords["mjd"] = ("time", timetable["mjd"])
        self.ds.coords["dmjd"] = ("time", timetable["dmjd"])
        self.ds.coords["scanid"] = ("time", timetable["scanid"])

    def calc_gst(self):
        """
        Compute Greenwich Sidereal Time.
        """
        from ....util.time import mjd2gst
        gst = mjd2gst(self.ds.mjd.values)
        self.ds.coords["gst"] = ("time", gst)

    def calc_azelfra(self, nproc=-1):
        """
        Compute AZ, EL and Field Rotation Angle (FRA) for each antenna
        and each observing time.

        Args:
            nproc (int, optional): 
                The number of processes used by ray. nproc=-1 doesn't use ray
                (i.e. single processing), nproc=0 uses the maximum number of
                CPUs.
        """
        from ....util.coords import xyz2lstazelfra
        from ....util.time import mjd2utc
        from ....util.units import DEG2RAD, RAD2DEG, RAD2HOUR
        from numpy import asarray

        utc = mjd2utc(self.ds.mjd.values)
        Nant = self.ds.dims["ant"]
        skycoord = self.get_skycoord()

        if nproc < 0:
            outputs = [xyz2lstazelfra(
                x=self.ds.x.values[iant],
                y=self.ds.y.values[iant],
                z=self.ds.z.values[iant],
                utc=utc,
                skycoord=skycoord,
                fr_pa_coeff=self.ds.fr_pa_coeff.values[iant],
                fr_el_coeff=self.ds.fr_el_coeff.values[iant],
                fr_offset=self.ds.fr_offset.values[iant] * DEG2RAD
            ) for iant in range(Nant)]
        else:
            import ray
            if nproc == 0:
                ray.init(num_cpus=None, ignore_reinit_error=True)
            else:
                ray.init(num_cpus=nproc, ignore_reinit_error=True)
            remote_func = ray.remote(xyz2lstazelfra)
            outputs = [remote_func.remote(
                x=self.ds.x.values[iant],
                y=self.ds.y.values[iant],
                z=self.ds.z.values[iant],
                utc=utc,
                skycoord=skycoord,
                fr_pa_coeff=self.ds.fr_pa_coeff.values[iant],
                fr_el_coeff=self.ds.fr_el_coeff.values[iant],
                fr_offset=self.ds.fr_offset.values[iant] * DEG2RAD
            ) for iant in range(Nant)]
            outputs = ray.get(outputs)

        outputs = asarray(outputs)
        self.ds.coords["lst"] = (["ant", "time"], outputs[:, 0, :]*RAD2HOUR)
        self.ds.coords["az"] = (["ant", "time"], outputs[:, 1, :]*RAD2DEG)
        self.ds.coords["el"] = (["ant", "time"], outputs[:, 2, :]*RAD2DEG)
        self.ds.coords["par"] = (["ant", "time"], outputs[:, 3, :]*RAD2DEG)
        self.ds.coords["fra"] = (["ant", "time"], outputs[:, 4, :]*RAD2DEG)

    def calc_sefd(self):
        """
        Compute SEFD using the source elevation, the zenith SEFD and opacity.

        Raises:
            ValueError: If elevation is not computed, raises an error
        """
        from numpy import zeros, sin, exp
        from ....util.units import DEG2RAD

        if "el" not in self.ds.coords.keys():
            msg = "No 'el' coordinates in ds. Please compute el first with the calc_azelfra method."
            logger.error(msg)
            raise ValueError(msg)

        Nant = self.ds.dims["ant"]
        Ntime = self.ds.dims["time"]
        Nstokes = self.ds.dims["stokes"]

        sefd = zeros([Nant, Ntime, Nstokes])
        for iant in range(Nant):
            secz = 1./sin(self.ds.el.values[iant] * DEG2RAD)
            tau0 = self.ds.tau0.values[iant]
            fact = exp(tau0 * (secz-1))
            for ipol in range(Nstokes):
                sefd0 = self.ds.sefd0.values[iant, ipol]
                sefd[iant, :, ipol] = sefd0*fact

        self.ds.coords["sefd"] = (["ant", "time", "stokes"], sefd)

    def get_skycoord(self):
        from astropy.coordinates import SkyCoord
        from smili2.util.units import DEG

        if "fk" in self.ds.attrs["coordsys"]:
            from astropy.time import Time
            equinox = Time(self.ds.attrs["equinox"], format="jyear")
            srccoord = SkyCoord(
                ra=self.ds.attrs["ra"] * DEG,
                dec=self.ds.attrs["dec"] * DEG,
                equinox=equinox,
                frame=self.ds.attrs["coordsys"]
            )
        elif "gcrs" in self.ds.attrs["coordsys"]:
            from astropy.time import Time
            obstime = Time(self.ds.attrs["equinox"], format="jyear")

            srccoord = SkyCoord(
                ra=self.ds.attrs["ra"] * DEG,
                dec=self.ds.attrs["dec"] * DEG,
                obstime=obstime,
                frame=self.ds.attrs["coordsys"]
            )
        elif "icrs" in self.ds.attrs["coordsys"]:
            srccoord = SkyCoord(
                ra=self.ds.attrs["ra"] * DEG,
                dec=self.ds.attrs["dec"] * DEG,
                frame=self.ds.attrs["coordsys"]
            )
        else:
            msg = "coordsys = %s is not supported" % (
                self.ds.attrs["coordsys"])
            logger.error(msg)
            raise ValueError(msg)

        return srccoord

    def gen_vistab(self, full_stokes=True, nproc=-1):
        """
        Generate empty visdata. 

        Args:
            full_stokes (bool, optional): 
                If True, generate full stokes data sets including cross polarization
                terms. If False, generate only dual stokes data sets (i.e. [RR, LL] or [XX, YY]).
                If caldata have only single polarization, this option will be 
                ignored and just single polarization data will be created. 
                Defaults to True.
            nproc (int, optional): 
                The number of processes used by ray. nproc=-1 doesn't use ray
                (i.e. single processing), nproc=0 uses the maximum number of
                CPUs.
        Returns:
            uvdata.uvdata.VisTable object
        """
        from astropy.coordinates import FK5
        from astropy.time import Time
        from numpy import concatenate, full, int64, zeros
        from itertools import combinations
        from xarray import Dataset
        from smili2.uvdata.uvdata.vis import VisTable

        calds = self.ds

        # number of antennas
        Nant = calds.dims["ant"]

        # number of baseline combinations
        Nbl = Nant * (Nant-1)//2

        # baseline combinations
        blids = list(combinations(range(Nant), 2))

        # source coordinate
        srccoord = self.get_skycoord().transform_to(
            FK5(equinox=Time(2000.0, format="jyear")))
        ra = srccoord.ra.radian
        dec = srccoord.dec.radian

        # polarizations
        Npol = calds.dims["stokes"]
        if Npol == 1:
            Nstokes = 1
            polidxs = ((0, 0))
        elif Npol == 2 and not full_stokes:
            Nstokes = 2
            polidxs = ((0, 0), (1, 1))
        elif Npol == 2 and full_stokes:
            Nstokes = 4
            polidxs = ((0, 0), (1, 1), (0, 1), (1, 0))
        else:
            msg = "input calibration data involves more than two polarizations"
            logger.error(msg)
            raise ValueError(msg)
        pols = calds.stokes.values
        stokes = [pols[polidxs[i][0]]+pols[polidxs[i][1]]
                  for i in range(Nstokes)]

        # compute uvw for each baseline
        if nproc < 0:
            outputs = [_calds2uvw_baseline(
                antid1=blids[ibl][0],
                antid2=blids[ibl][1],
                calds=calds,
                ra=ra, dec=dec,
                polidxs=polidxs
            ) for ibl in range(Nbl)]
        else:
            import ray
            if nproc == 0:
                ray.init(num_cpus=None, ignore_reinit_error=True)
            else:
                ray.init(num_cpus=nproc, ignore_reinit_error=True)
            remote_func = ray.remote(_calds2uvw_baseline)
            outputs = [remote_func.remote(
                antid1=blids[ibl][0],
                antid2=blids[ibl][1],
                calds=calds,
                ra=ra, dec=dec,
                polidxs=polidxs
            ) for ibl in range(Nbl)]
            outputs = ray.get(outputs)

        # compute vistab
        def concat(x): return concatenate(x, axis=0)

        ds = Dataset(
            coords=dict(
                mjd=("data", concat([outputs[ibl][0] for ibl in range(Nbl)])),
                dmjd=("data", concat([outputs[ibl][1] for ibl in range(Nbl)])),
                scanid=("data", int64(
                    concat([outputs[ibl][2] for ibl in range(Nbl)]))),
                antid1=("data", int64(
                    concat([outputs[ibl][3] for ibl in range(Nbl)]))),
                antid2=("data", int64(
                    concat([outputs[ibl][4] for ibl in range(Nbl)]))),
                usec=("data", concat([outputs[ibl][5] for ibl in range(Nbl)])),
                vsec=("data", concat([outputs[ibl][6] for ibl in range(Nbl)])),
                wsec=("data", concat([outputs[ibl][7] for ibl in range(Nbl)])),
                sigma=(["data", "if", "ch", "stokes"], concat(
                    [outputs[ibl][8] for ibl in range(Nbl)])),
                stokes=("stokes", stokes),
            )
        )

        ds["vis"] = (ds.sigma.dims, zeros(
            shape=ds.sigma.shape, dtype="complex128"))

        ds.coords["flag"] = (ds.sigma.dims, full(
            fill_value=1, shape=ds.sigma.shape, dtype="int32"))

        return VisTable(ds=ds)

    @classmethod
    def from_uvd(cls, uvd, timetable=None):
        from xarray import Dataset

        antds = uvd.ant.ds
        freqds = uvd.freq.ds
        srcds = uvd.src.ds

        coords = dict(
            freq=(["if", "ch"], freqds.freq.data),
            ch_bw=(["if"], freqds.ch_bw.values)
        )
        for key in antds.coords.keys():
            coords[key] = (antds.coords[key].dims, antds.coords[key].values)

        attrs = dict(
            ra=srcds.attrs["ra"],
            dec=srcds.attrs["dec"],
            equinox=srcds.attrs["equinox"],
            coordsys=srcds.attrs["coordsys"]
        )

        ds = Dataset(
            coords=coords,
            attrs=attrs
        )

        return cls(ds=ds)


def _calds2uvw_baseline(antid1, antid2, calds, ra, dec, polidxs):
    """
    Support function for CalData.gen_vistab(). This function will generate
    a subset of coordinate data (e.g. u, v, w, sigma) for a given antenna combination.

    Args:
        antid1 ([type]): [description]
        antid2 ([type]): [description]
        calds ([type]): [description]
        ra ([type]): [description]
        dec ([type]): [description]
        polidxs ([type]): [description]

    Returns:
        [type]: [description]
    """
    from numpy import full, zeros, sqrt, logical_and, where
    from itertools import product
    from ....util.units import HOUR2RAD
    from ....util.coords import xyz2uvwsec

    loc1 = calds.ant == antid1
    loc2 = calds.ant == antid2

    # check common time ranges
    el1 = calds.el.loc[loc1].values[0]
    el2 = calds.el.loc[loc2].values[0]

    elmin1 = calds.el_min.loc[loc1].values[0]
    elmin2 = calds.el_min.loc[loc2].values[0]

    elmax1 = calds.el_max.loc[loc1].values[0]
    elmax2 = calds.el_max.loc[loc2].values[0]

    itime_1 = logical_and(el1 >= elmin1, el1 <= elmax1)
    itime_2 = logical_and(el2 >= elmin2, el2 <= elmax2)
    itime = logical_and(itime_1, itime_2)
    if True not in itime:
        logger.info("No common time between antennas %d and %d" %
                    (antid1, antid2))
    itime_idx = where(itime)

    # get time stamps
    mjd = calds.mjd.values[itime_idx]
    dmjd = calds.dmjd.values[itime_idx]
    scanid = calds.scanid.values[itime_idx]
    gst = calds.gst.values[itime_idx]

    # antenna ID
    Ntime = len(mjd)
    antid1_arr = full(shape=[Ntime], fill_value=antid1)
    antid2_arr = full(shape=[Ntime], fill_value=antid2)

    # get dimensions for frequency
    Nif = calds.dims["if"]
    Nch = calds.dims["ch"]
    Nstokes = len(polidxs)

    # get elements necesary to compute sigma
    # shape: time, pol
    sefd1 = calds.sefd.loc[loc1].values[0][itime_idx]
    sefd2 = calds.sefd.loc[loc2].values[0][itime_idx]
    sqrtdt = sqrt(dmjd * 86400)  # shape: time
    sqrtdnu = sqrt(calds.ch_bw.values)  # shape: if

    # compute sigma
    sigma = zeros([Ntime, Nif, Nch, Nstokes])
    for istokes in range(Nstokes):
        # geometric mean of SEFD
        sefd_gm = sqrt(sefd1[:, polidxs[istokes][0]]
                       * sefd2[:, polidxs[istokes][1]])
        for i_seg, i_if in product(range(Ntime), range(Nif)):
            sigma[i_seg, i_if, :, istokes] = sefd_gm[i_seg] / \
                sqrtdt[i_seg] / sqrtdnu[i_if]

    # compute other arrays
    usec, vsec, wsec = xyz2uvwsec(
        gst=gst * HOUR2RAD,
        ra=ra, dec=dec,
        x1=calds.x.loc[loc1].values[0],
        y1=calds.y.loc[loc1].values[0],
        z1=calds.z.loc[loc1].values[0],
        x2=calds.x.loc[loc2].values[0],
        y2=calds.y.loc[loc2].values[0],
        z2=calds.z.loc[loc2].values[0],
    )

    return (mjd, dmjd, scanid, antid1_arr, antid2_arr, usec, vsec, wsec, sigma)
